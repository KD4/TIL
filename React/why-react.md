# 왜 React 인가?

React를 사용하고 있는 페이스북 웹앱을 생각하면 될 것 같습니다. 페이스북의 글로벌 Notification, 페이스북 그룹 리스트, 댓글 창, 채팅 창 같은 인터페이스들은 시간이 지날수록 다른 사람들이 댓글을 달거나 말을 걸면 신호에 따라 서버에서 데이터를 요청해 업데이트하고, 이에 맞춰 뷰를 변경해줘야 합니다. 예를 들어, 이 컴포넌트들을 jQuery로 작성했다고 생각해 봅시다. 보통은 jQuery#append와 jQuery#remove와 같은 imperative(명령형) API를 이용해 XHR 이벤트의 발생에 따라 뷰 데이터를 갱신해줘야 할 것입니다.

### 관심사의 분리
이런 컴포넌트들이 늘어날 때마다 개별적으로 뷰 로직을 짜야 하는 것은 끔찍한 일입니다. 또한, 뷰와 모델의 로직이 잘 분리되지 않고, 뒤섞이기 쉽습니다. 유지보수를 신경 쓰는 개발자들은 모델 데이터를 변경하는 로직과 뷰 로직을 분리하기 위해 나만의 ‘뷰 데이터 관리 도구’를 만들어, Separation of Concern (관심사의 분리)을 달성하게 되어 있습니다. 그러므로 Backbone.js이나 Angular.js와 같은 라이브러리들이 자연히 등장한 것이기도 합니다.
MV* 라이브러리의 선조이자, 가장 많이 사용하고 있는 라이브러리 중 하나인 Backbone.js은 보통 모델과 뷰를 분리해 앱을 작성합니다. 모델이 업데이트되면, 모델을 지켜보고 있는 뷰에서 템플릿을 새로 렌더링합니다. Backbone은 꽤 단순한 라이브러리이고 위의 jQuery를 이용해 뷰와 모델이 뒤섞여 있는 경우보다는 낫지만, 모델마다 적지 않은 줄의 절차적 코드로 이 업데이트 과정을 표현해야 합니다. 이런 과정을 덜 불편하게 하려고 Marionette 등의 라이브러리가 나와 있긴 하지만, 줄의 양이 줄어드는 정도일 뿐　큰 차이는 없습니다. 우리가 로직에 집중하기 위해서는 좀 더 많은 부분, 특히 뷰의 업데이트가 자동으로 이뤄져야 할 필요가 있습니다. React는 뷰 업데이트 과정을 단순화할 수 있게 도와줍니다.

### 선언적인 API
React를 살펴보면, 생각보다 public 하게 사용할 수 있는 API는 몇 개 되지 않습니다. 왜냐하면, React에서 사용하는 치환형 언어인 JSX를 통해 어떤 형태로 뷰 데이터가 보여져야 하는지에 대해 선언적으로 기술하기 때문입니다. (복잡한 로직을 가진 뷰라면 현실적으로는 완전히 선언적인 코드를 짜기는 어렵지만, 어쨌든 ‘우리가 보고 싶은 결과물을 써 놓는다.’ 라는 점은 같습니다) 명령형 API에 익숙한 입문자들이 React를 처음 접할 때 가장 많이 하는 실수 중 하나는, React의 라이프사이클 메서드 안에서 jQuery로 DOM을 조작하려고 하는 것입니다. React는 중간 과정이 아닌 결과물을 기술하는 것이기 때문에 그럴 필요가 (거의) 없습니다.
관심사의 분리와 선언적인 API가 주는 장점을 생각하면, React의 등장은 웹 프론트엔드 개발의 자연스러운 진화의 결과라고 볼 수 있습니다.
