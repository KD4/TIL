Observable
====================================

Rx에서 옵저버는 Observable을 구독한다. Obseravable이 배출하는 하나 또는 연속된 항목에 옵저버는 반응한다.

이러한 패턴은 동시성 연산을 가능하게 한다. 

## 배경

절차지향 프로그래밍과는 다르게 리액티브 프로그래밍에서는 옵저버에 의해 임의의 순서에 따라 병렬로 실행되고 결과는 나중에 리턴된다. 즉, 메서드 호출보다는 옵저버블 안에 데이터를 조회하고 변환하는 메커니즘을 정의한 후 옵저버블이 이벤트를 발생시키면 옵저버의 관찰자가 그 순간을 감지하고 준비된 연산을 실행시켜 결과를 리턴하는 메커니즘이다. 

이 때문에 업저버블을 구독한다고 표현한다.

우리가 옵저버라고 말하는 것은 통상 리액터 패턴이라고 말한다.


## 옵저버 생성
일반적인 절차지향 프로그래밍에서는 다음과 같은 흐름으로 코드를 작성한다.

1. 메서드를 호출한다.
2. 메서드가 리턴한 값을 변수에 저장한다
3. 결과 값을 가진 변수를 통해 연산을 또 정의한다.

```
returnVal = someMethod(itsParams);
```

하지만 비동기 모델에서는 아래와 같은 흐름대로 코드가 실행된다.
1. 비동기 메소드 호출로 결과를 리턴받고 필요한 동작을 처리하는 메서드를 정의한다. 
2. 옵저버블로 비동기 호출을 정의한다.
3. 구독을 통해 옵저버와 옵저버블을 연결한다.

```groovy
// 옵저버의 onNext 핸들러를 정의한다. 
def myOnNext = { it -> /* do something */ };
// 옵저버블을 정의한다.
def myObservable = someObservable(itsPrams);
// 옵저버가 옵저버블을 구독한다. 그리고 옵저버블 실행
myObservable.subscribe(myOnNext);
```

## onNext, onCompleted, onError
 subscribe 메서드를 통해 옵저버와 옵저버블을 연결한다.

 ### onNext
 Observable은 새로운 항목들을 배출할 때마다 이 메서드를 호출한다. 이 메서드는 Observable이 배출하는 항목을 파라미터로 전달 받는다.

 ### onError
 Observable은 기대하는 데이터가 생성되지 않았거나 다른 이류로 오류가 발생한 경우 오류를 알리기 위해 이 메서드를 호출한다. 이 메서드가 호출되면 onNext나 onCompleted는 더 이상 호출되지 않는다. 

 ### onCompleted
 오류가 발생하지 않았다면 Observable은 마지막 onNext를 호출한 후 이 메서드를 호출한다.

## 구독 해지
ReactiveX 구현체 중에는 Subscriber라는 특별한 옵저버 인터페이스가 있는데 이 인터페이스는 unsubscribe라는 메서드를 제공한다. 현재 구독 중인 Observable 중, 옵저버가 더 이상 구독을 원하지 않는 경우에는 이 메서드를 호출해서 구독을 해지할 수 있다. 만약 더 이상 관심있는 다른 옵저버가 존재하지 않는다면 Observable들은 새로운 항목들을 배출하지 않는다.

unsubscribe는 연산자 체인을 통해 옵저버가 구독하고 있었던 Observable들이 더 이상 항목들을 배출하지 못하도록 체인 안에 연결된 링크들을 끊어 버린다.

## 명명 규칙에 관한 참고 내용
ReactiveX를 구현하는 언어들은 자신 만의 독특한 특징들을 갖고있다. 그렇다고 반드시 지켜야 하는 강제성이 있는 규칙들이 존재하는 것은 아니지만, 언어별 구현체 간에 공통적으로 유지해야 하는 많은 명명 규칙들이 존재한다.

뿐만 아니라, 이들 규칙 간에는 각기 다른 문맥에서 서로 다른 함축적인 의미로 사용되는 것들도 있으며 특정 언어의 관용구에서는 상당히 어색한 의미로 해석되기도 한다.

예를 들면, (onNext, onCompleted, onError 같은) onEvent 네이밍 패턴이 존재하는데, 어떤 문맥에서는 이런 이름들이 어떤 핸들러가 등록 되었는지를 가리키는 메서드로 사용되기도 한다. 하지만, ReactiveX에서는 이벤트 핸들러 자체를 의미한다.

## “뜨거운(Hot)” , “차가운(Cold)” Observable
그럼 Observable은 연속된 항목들을 언제 배출할까? 이 질문에 대한 대답은, "Observable에 따라 다르다"이다. “뜨거운” Observable은 생성되자 마자 항목들을 배출하기도 하기 때문에, 이 Observable을 구독하는 옵저버들은 어떤 경우에는 항목들이 배출되는 중간부터 Observable을 구독할 수 있다. 반대로, “차가운” Observable은 옵저버가 구독할 때 까지 항목을 배출하지 않기 때문에 이 Observable을 구독하는 옵저버는 Observable이 배출하는 항목 전체를 구독할 수 있도록 보장 받는다.

ReactiveX의 구현 코드 중에는 “연결 가능한(Connectable)” Observable이라고 불리는 Observable 객체가 존재하는데, 이 Observable은 옵저버의 구독 여부와는 상관 없이 자신의 Connect 메서드가 호출되기 전까지 항목들을 배출하지 않는다.

