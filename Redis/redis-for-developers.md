
# 마이크로서비스 아키텍처와 레디스

소프트웨어의 아키텍처는 중앙 집약적인 모놀리틱 아키텍처에서 마이크로서비스 아키텍처로 점차 변화하고 있다. 이에 따라 데이터 저장소의 특징 역시 다양하게 발전해왔다. 과거 모놀리틱 아키텍처에서는 관계 집약적인 데이터를 하나의 서비스로 관리하기 때문에 관계형 데이터베이스가 주 데이터 매니지먼트 시스템으로 굳어져왔지만 마이크로 서비스에서 각 서비스는 각각 하나의 역할을 수행하기 위해 설계된 독립적인 파트이기 때문에, 서비스별 비즈니스 특성과 데이터의 형태를 고려해 관계형 데이터베이스 또는 NoSQL 데이터베이스를 선택해서 사용할 수 있게 됐다.

## NoSQL이란?
NoSQL이란 용어는 No SQL 혹은 Not Only SQL을 의미한다. SQL은 standard query language란 의미로 관계형 데티어베이스에서 사용하는 쿼리를 뜻한다. NoSQL은 일반적으로 더 빠른 응답, 나은 확장성, 고가용성, 단순성, 유연성 등의 특징이 있다. 
NoSQL도 다양한 유형이 있는데 각각 유형을 살펴보자.

### 그래프 유형
그래프 유형의 데이터베이스는 엔티티 간의 관계를 효율적으로 저장하도록 설계됐다. 이 유형에서는 노드, 엣지, 속성으로 데이터를 나타내고 데이터의 엔티티는 노드로 표현하며 데이터 사이의 관계를 에지로 나타낸다. 에지는 상항 시작 노드, 끝 노드, 유형과 방향을 가지며 상-하위 관계, 동작, 소유자 등의 정보를 저장한다. 

그래프 유형의 데이터베이스는 관계를 저장하고 표현할 대 유용하게 사용될 수 있으며, 저장되는 속성의 크기가 크거나 매우 많은 속성을 저장할 때는 적합하지 않을 수 있다. 

추천 서비스나 SNS 친구 관계를 나타낼 때 유용하게 사용할 수 있다.

### 칼럼 유형
칼럼 유형의 NoSQL은 테이블을 행이 아닌 열 기준으로 저장한다는 철학으로 설계됐다. 데이터는 하나의 열에 중첩된 키-값 형태로 저장될 수 있기 때문에 기존의 관계형 데이터베이스와 비교했을 때보다 유연한 스키마를 저장할 수 있다.

또한 대량의 데이터에 대한 집계 쿼리를 다른 유형보다 훨씬 빠르게 처리할 수 있어 분석, 보고, 빅데이터 처리에 적합하며 대표적인 데이터베이스로는 Cassandra, HBase 등이 있다.
https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52606

### 문서 유형
문서 유형의 데이터베이스는 JSON 형태로 데이터가 저장돼, 개발자들이 편하게 사용할 수 있는 구조다. 

또한 스키마가 정해져 있지 않기 때문에 애플리케이션에 맞게 데이터를 그대로 저장할 수 있어 유연성이 크다는 장점이 존재한다. 

데이터를 저장하거나 검색하는데 효과적이며 대표적인 데이터베이스로는 MongoDB, CouchDB, DocumentDB가 있다.

### 키-값 유형
키-값 유형은 가장 단순하고 빠르다. 키값 유형에서 키는 관계형 디비의 PK라고도 생각할 수 있다. 다른 디비보다 빠른 응답속도를 보장하며 대표적인 데이터베이스로는 Redis, ElastiCache, DynamoDB, Memcached가 있다.

## Redis란?
Remote dictionary server 의 약자인 레디스는 고성능 키-값 유형의 인메모리 NoSQL 데이터베이스로, 오픈 소스 기반의 데이터 저장소다.

### 레디스의 특징
레디스의 특징은 실시간 응답, 단순성, 고가용성, 확장성 등이 있는데 어떻게 이런 특징을 가지게 됐는지 자세히 봐보자.

#### 실시간 응답(빠른 성능)
레디스는 인메모리 데이터베이스로 온디스크 데이터베이스와는 다르게 모든 데이터가 컴퓨터의 메모리에서 관리된다. 디스크에 접근하는 과정이 필요 업식 때문에 데이터 처리 성능이 굉장히 빠르다는 장점을 갖고 있다.

#### 단순성
레디스는 키-값 형태로 데이터를 저장할 수 있는 데이터 저장소다. 레디스에 저장되는 값들은 문자열 뿐만 아니라 해시, 셋 등 복잡하고 다양한 자료 구조를 저장할 수 있고 이는 애플리케이션에서 쉽게 사용할 수 있다.
임피던스 불일치는 기존 관계형 데이터베이스의 테이블 구조와 프로그래밍 언어에서 사용하는 자료 구조의 구조, 기능적 차이로 인해 발생하는 충돌을 의미하는데, 레디스에서는 임피던스 불일치가 최소화된다.

레디스는 이벤트 루프로 동작하는 싱글 스레드 데이터베이스이다. 실제로는 메인 스레드 1개와 별도의 스레드 3개, 총 4개가 동작하지만 클리언트 커맨드를 처리하는 부분은 싱글 스레드로 동작한다. 
이 때문에 동시성으로 인한 동기화 처리가 필요 없어서 매우 빠르고 안정적으로 사용자 커멘드를 처리할 수 있지만 하나의 커멘드가 너무 오래 걸린다면 다른 쿼리들이 대기하는 불상사가 벌어지게 된다. (이렇기 때문에 설정으로 너무 오래 걸리는 쿼리(Keys 등)은 막아둔다)

#### 고가용성
레디스는 자체적으로 HA(High Availability) 기능을 제공한다. 복제를 통해 데이터를 여러 서버에 분산시킬 수 있으며 센티널은 장애 상황을 탐지해 자동으로 페일오버를 시켜준다. 

#### 확장성
레디스에서 클러스터 모드를 사용한다면 손쉬운 수평적 확장이 가능하다. 데이터는 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며 여러 개의 복제본이 생성될 수 있다. 클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로 감시하고 있으며 이를 이용해 클러스터의 마스터 노드에 문제가 발생하면 자동으로 페일오버를 시켜 고가용성을 유지할 수 있다.


## 마이크로서비스 아키텍처와 레디스
더 이상 관계형 데이터베이스만으로는 현대 제품에서 요구되는 모든 기능을 커버할 수 없으며, 이와 같은 요구사항을 커버하기 위해서 Redis를 활용해야한다.

#### 데이터 저장소로서의 레디스
레디스는 메모리에 있는 데이터가 영구 저장되지 않기 때문에 데이터 저장소로 영속성을 고민할 수 있으나, 레디스의 데이터는 AOF(Append Only File)와 RDB(Redis Database) 형식으로 디스크에 주기적으로 저장할 수 있다.
(일종의 백업, 완전하지는 않음)

#### 메시지 브로커로서의 레디스
레디스는 Pub/Sub 기능을 통해서 이벤트를 브로드캐스팅할 수 있고(캐시 expire 사용 가능) list 자료 구조를 사용해 메시징 큐로 사용할 수 있다. (카프카 lag 해소를 임시로 해결) 또 레디스의 Stream 구조를 이용하면 카프카처럼 소비자 그룹에게 일괄 분산 처리도 가능하다.

# 02 레디스 시작하기

### 소스 파일을 이용해 레디스 설치하기
OS별로 지원하는 패키지 매니저를 통해서 Redis를 손쉽게 설치할 수 있지만 레디스와 관련된 파일이 여러 군데 흩어져 저장되기 때문에 관리가 어려울 수 있고 오프라인 환경에서는 설치가 어렵다는 단점이 있다. 

소스 파일을 받아서 처리할 때는 gcc 버전 4.6 이상이 필요하다.
다음은 centos에서 소스파일을 이용한 레디스 설치 방법이다.

```
$ wget https://download.redis.io/redis-stable.tar.gz
$ tar -zxvf redis-7.0.8.tar.gz
$ mv redis-7.0.8 redis
$ cd redis
$ make
$ make PREFIX=/home/centos/redis install
```

이후 `$ bin/redis-server redis.conf` 커맨드로 레디스를 포그라운드 모드로 시작할 수 있다. redis.conf 파일은 레디스의 설정 파일을 의미한다.

## 레디스 환경 구성
레디스 서버를 구동하기 위해서 알면 좋을 일부 설정 값들에 대해서 알아보자.

### 서버 환경 설정 변경
#### Open files 확인
레디스의 기본 maxclients 설정값은 10000이다. 하지만 이 값은 파일 디스크립터 수에 영향을 받는다. 레디스 프로세스에서 사용하는 파일 디스크립터 수는 32개로 maxclients 값 + 32가 레디스가 사용하는 OS의 파일 디스크립터 수이다.
```
파일 디스크립터
- Unix/Linux에서, 모든 파일I/O 시스템호출은, 
- 반드시, 파일기술자를 통해, 열려있는 파일을 참조함
- 파일 관리용 시스템호출 : create(), open(), read(), write(), close(), ioctl() 등
- 열려있는 파일 종류 : (파이프,FIFO,소켓,터미널,장치 파일,일반 파일 등)
- 번호 생성 주체 : 커널에 의해 만들어지는 값(번호)
```

#### THP 비활성화
리눅스는 메모리를 페이지 단위로 관리하며 기본 페이지는 4096 바이트(4KB)로 고정돼 있다. 메모리 크기가 커질수록 페이지를 관리하는 테이블인 TLB의 크기도 커져 메모리를 사용할 때 오버헤드가 발생하는 이슈로 인해 페이지를 크게 만든 뒤 자동으로 관리하는 THP 기능이 도입됐다.

```
TLB는 각 페이지의 실제 위치를 (매핑 정보) 메모리에 저장해서 이 테이블 자체가 잡아먹는 메모리가 커진다는 뜻

Linux는 메모리를 Page라는 블록으로 분할해 관리를 합니다. 기본 페이지의 크기는 4KB인데 만약 1기가의 메모리를 Page로 분할하게되면

256,000개의 Page로 분할된다. 메모리가 커질수록 Page의 개수가 늘어나면서 페이지를 관리하는 TLB(transparent lookaside buffer)의 크기가

같이 커지게 되는데 이걸 방지하기위해 Page자체의 크기를 키워 Page개수를 줄여 TLB의 크기를 작게 만드는 기술을 THP(Transparent Huge Pages) 
```

#### vm.overcommit_memory=1로 변경
레디스는 디스크에 파일을 저장할 때 fork()를 이용해 백그라운드 프로세스를 만드는데, 이때 COW(Copy On Write) 라는 매커니즘이 동작한다. 이 매커니즘에서는 부모 프로세스와 자식 프로세스가 동일한 메모리 페이지를 공유하다가 레디스의 데이터가 변경될 때마다 메모리 페이지를 복사하기 때문에 데이터 변경이 많이 발생하면 메모리 사용량이 빠르게 증가할 수 있다. 

따라서 레디스 프로세스가 실행되는 도중 메모리를 순간적으로 초과해 할당해야 하는 상황이 발생할 수 있으며, 이를 위해 vm.overcommit_memory를 1로 설정하는 것이 좋다. 기본 값은 0으로 필요한 메모리를 초과해 할당되는 것을 제한한다. 이 값은 1로 설정해서 메모리를 필요할 때 추가로 할당할 수 있도록 조절한다.

#### somaxconn과 syn_backlog 설정 변경
레디스 설정 파일의 tcp-backlog 파라미터는 레디스 인스턴스가 클라이언트와 통신할 때 사용하는 tcp backlog 큐의 크기를 지정한다. 이 값은 서버의 somaxconn(socket max connection)과 syn_backlog 값보다 클 수 없으므로 OS 값을 수정해주자.

```
tcp-backlog는 tcp 연결이 들어오는데 너무 많은 커넥션이 들어와 처리할 수 없는 경우 쌓아두는 백로그이다. 이 값은 당연하게도 커널의 리스닝 소켓과 백로그 최댓값에 영향을 받을 수 밖에 없다.
```

### 레디스 설정 파일 변경
레디스를 실행할 때에는 redis.conf라는 이름의 설정 파일을 이용한다. 이 파일에서 설정해야할 혹은 알아야할 필수값들을 알아보자

#### port
기본값: 6379, 커넥션이 지정된 포트로 레디스 서버에 접속할 수 있도록 허용한다.

#### bind
기본값: 127.0.0.1-::1
레디스가 설치된 서버 외부에서 레디스 인스턴스로 바로 접근하는 것을 허용하기 위해서는 해당 설정값을 변경해야 한다.

#### protected-mode
기본값: yes
패스워드 설정이 필요하다는 플래그, 원격에서 접근할 때 요구된다.

#### requirepass / masterauth
기본값: 없음
requirepass: 패스워드값, masterauth: 마스터의 패스워드를 복제할것인가?

#### daemonize
기본값: no
레디스 프로세스를 데몬으로 실행시킬지 여부, yes로 해야 백그라운드로 실행됨

#### dir
기본값: ./
레디스 워킹 디렉토리. 로그 파일ㄹ이나 백업 파일 등 인스턴스를 실행하면서 만들어지는 파일의 위치