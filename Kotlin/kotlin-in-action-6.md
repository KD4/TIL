코틀린 타입 시스템
===========================

#### 코틀린과 자바의 가장 중요한 차이는 코틀린 타입 스시템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.

#### 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할 지 명확히 이해할 수 있고 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.

#### as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.

#### 느낌표를 이중(!!)으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 바꿀 수 있다. !!는 컴파일러에게 "나는 이 값이 null이 아님을 알 고 있다. 아니면 예외가 발생해도 감수하겠다."를 알려준다.

#### !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤식에 예외가 발생했는지에 대한 정보는 들어있지 않다. 어떤 값이 널이었는지 확실히하기 위해 여러 !! 단언문을 한 줄에 쓰지말자.

#### 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다. 자바 타입은 코틀린에서 플랫폼 타입으로 표현된다. 플랫폼 타입은 널이 될 수 있는 타입이나 널이 될 수 없는 타입 모두를 사용할 수 있다.

```
코틀린이 왜 플랫폼 타입을 도입했는가?
모든 자바타입을 널이 될 수 있는 타입으로 다루면 더 안전하지 않을까? 물론 그래도 되지만 모든 타입을 널이 될 수 있는 타입으로 다루면 결코 널이 될 수 없는 값에 대해서도 불필요한 널 검사가 들어간다.
특히 제네릭을 다룰 떄 상황이 더 나빠진다. 예를 들어 모든자바 ArrayList<String>을 코틀린에서 ArrayList<String?>?처럼 다루면 이 배열의 원소에 접근할 때마다 널 검사를 수행하거나 안전한 캐스트를 수행해야한다. 하지만 이런식으로 처리하면 널 안정성으로 얻는 이익보다 검사에 드는 비용이 훨씬 더 커진다. 또한 모든 타입의 값에 대해 항상 널 검사를 작성하는 것은 너무 성가신 일이다. 그래서 코틀린 설꼐자들은 자바의 타입을 가져온 경우 프로그래머에게 그 타입을 제대로 처리할 책임을 부여하는 실용적인 접근 방법을 택했다.
```

#### 플랫폼 타입 표기인 ! 표기는 String! 타입의 널 가능성에 대해 아무 정도 없다는 뜻이다. 

#### 자바 클래스나 인터페이슬르 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다. 그러니까 이왕이면 nullable로 구현하자. 자바는 nullable하니까.

#### 코틀린은 원시타입과 래퍼타입을 구분하지 않는다.

#### coerceIn을 사용해 값을 특정 범위로 제한할 수 있다.
```kotlin
fun showPregress(progress: Int) {
    val percent = progress.coerceIn(0, 100)
    println("We're ${percent} % done!)
}

>>> showProgress(146)
We're 100% done!
```

#### 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바 래퍼타입으로 컴파일된다.

#### 자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다. 자바 메소드에서 Objet를 인자로 받거나 반환하면 코틀린에서는 Any!로 취급한다. (플랫폼타입)

#### 코틀린 Unit 타입은 자바 void와 같은 기능을 한다. Unit은 모든 기능을 갖는 일반적인 타입이며 void와 달리 Unit을 타입인자로 쓸 수 있다. Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다. 자바 인터페이스 정의가 값 반환을 명시하지만 코틀린 구현체에서는 필요 없을 때 유용

#### Nothing 이 반환 타입인 함수가 결코 정상 종료되지 않음을 알고 그 함수를 호출하는 코드를 분석할 때 사용한다.

#### 코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렌셕 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다. `Collection <- MutableCollection`

#### 코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소타입은 그 타입 파라미터에 의해 결정된다.

