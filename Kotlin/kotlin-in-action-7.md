연산자 오버로딩과 기타 관례
==========================

#### 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례라고 부른다. 코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자다.

#### 연산자를 오버로딩하는 함수 앞에는 꼭 operator가 있어야 한다. operator 키워드를 붙임으로서 어떤 함쑤가 관례를 따르는 함수임을 명확히 할 수 있다.

```kotlin
operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```

|식|함수 이름|
|-----|----|
|a * b|times|
|a / b|div|
|a % b|rem|
|a + b|plus|
|a - b|minus|

#### 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 산술 연산 우선순위를 따른다. 

#### 코틀린의 == 연산자 호출은 equals 메소드 호출로 컴파일 된다. 즉 비교 연산자는 equals와 compareTo 메소드로 변환된다.

#### 클래스에 get, set, contains 라는 함수를 정의하면 그 클래스의 인스턴스에 대해 []와 in 연산을 사용할 수 있고, 그 객체를 코틀린 컬렉션 객체와 비슷하게 다룰 수 있다 

#### 미리 정해진 관례를 따라 rangeTo, iterator 함수를 정의하면 범위를 만들거나 컬렉션과 배열의 원소를 이터레이션할 수 있다.

#### 구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있다.

#### 위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화 하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있다. 

#### 표준 라이브러리 함수인 lazy를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있다.

#### Delegates.observable 함수를 사용하면 프로퍼티 변경을 관찰할 수 있는 관찰자를 쉽게 추가할 수 있다.

#### 맵을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있다.

