## 객체 프로퍼티 삭제하기
객체의 프로퍼티 자체를 삭제하기 위해서는 delete 연산자를 사용해야한다.
삭제하고자 하는 프로퍼티에 null 혹은 undefined를 할당하는 것은 단지 그 프로퍼티에 값을 할당하는 행위에 불과하다.

## 프로토타입 기반 상속
프로토타입을 이용해 복잡한 코드를 작성하기 전에 반드시 프로토타입 상속 (Prototypal Inheritance) 모델을 완벽하게 이해하고 있어야 한다. 뿐만아니라 프로토타입 체인과 관련된 성능 문제로 고생하지 않으려면 프로토타입 체인이 너무 길지 않도록 항상 주의하고 적당히 끊어줘야 한다. 마지막으로 새로운 JavaScript 기능에 대한 호환성 유지 목적이 아니라면 절대로 네이티브 프로토타입을 확장하지마라.

## hasOwnProperty
어떤 객체 안의 정의된 프로퍼티가 있는지 확인하는 메소드이다. 모든 객체가 Object에 정의된 이 메소드를 재정의해서 사용하고 있는데, 프로토타입을 순회하지 않고 객체 안에 있는 프로퍼티 유무를 찾을 때 유용하다.
성능을 위해서는 반복문 사이에서도 hasOwnProperty를 반드시 사용해야한다.

## Arguments
모든 함수 스코프에는 Arguments라는 특별한 변수가 있다.
이 Arguments 변수는 Array처럼 동작하면서 iterable하지만 Arrays.prototype 을 상속받지 않으므로 Arrays.slice와 같은 메소드를 사용할 수는 없다.

## Function.call 과 Function.apply
apply는 매개변수를 배열로 받고 call은 인자로 받는다.
그래서 동적으로 사용해야할 떄는 apply를 사용한다.

## Arrays에서 for in은 사용하면 안된다.
for in은 스코프 체인을 모두 훑기때문에 성능이 반으로 줄어든다.
최적의 성능을 위해서는 for문을 사용하고 length 프로퍼티 값을 캐시해야 한다. 배열에 for in을 사용하면 성능도 떨어지고 버그 나기도 쉽다.

## 연산자
삼중 등호 연산자를 사용할 것을 강력하게 권한다. 비교하기 위해서 타입 변환이 필요하면 언어의 복잡한 변환 규칙에 맡기지 말고 꼭 명시적으로 변환한 후에 비교해야 한다.

## 객체의 타입을 검사하는 방법
객체의 타입을 검사하려면 Object.prototype.toString를 사용해야 한다. 다른 방법은 신뢰할 수 없다. 위 표에서 보여준 것처럼 typeof가 반환하는 값은 표준에 나와 있지 않기 때문에 구현방법도 제각각이다.

변수가 정의됐는지 확인할 때를 제외하고 가급적 typeof는 피해야한다.
