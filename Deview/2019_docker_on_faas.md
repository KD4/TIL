ms 단위의 Serverless world에서 Docker의 성능 한계 극복하기
===========================================

## 발표 주제
서버리스 컴퓨팅이란? 아파치 오픈위스크. 도커 데민이 야기할 수 있는 성능 이슈, 극복 방법, 커미터 경험 공유

주로 Openwhisk 이슈에 대해 공유할 것 같고, deamon 사용시 이슈에 대해 공부

serverless에 관심도는 계속 높아지고 컨퍼런스도 많이 열리고 있다.

클라우드 컴퓨팅의 미래는 서버리스라고 생각한다~

#### Cloud의 진화과정
PM> VM > Container > Serverless

하드웨어 공유, VM 리소스 공유, 시간축으로 리소스 공유 방식으로 발전됨

#### Serverless의 종류
BaaS DaaS FaaS가 있음

#### What is OpenWhisk?
Serverless 오픈소스 플랫폼

외부 이벤트를 셋업해주는 Feed

사용자의 함수를 오픈위스크에서는 액션이라고 부르고, 다양한 언어로 작성 가능하다.

이벤트가 반응했을때 특정 액션을 실행하기 위해서 트리거가 있고 어떤 액션과 연결할지 결정하는 것을 rule이라고 한다.

사용자의 함수를 오픈위스크에서는 액션이라고 부른다

Nginx>controller>kafka> invoker는 도커로 구성됨

CouchDB가 액션과 인증 정보를 저장함

#### 액션의 시작 형태
Cold Start: 컨테이너 생성, 코드 초기화, 코드 실행. 느릴듯?

Prewarmed Start: 코드 초기화, 코드 실행, 중간 속도

Warmed start: 코드 실행하면됨. 빠름

### OpenWhisk에서 스케줄링

어떤 invoker로 action을 보내느냐

모든 인보커로 실시간으로 리소스 정보를 수집하고 다른 컨트롤러 스케줄링

실시간성을 보장하면서?

#### Apache OpenWhisk에서는?

1. Hash 함수를 통함 위치 결정
Hash(actioon) => 0
컨테이너의 위치를 고려할 필요 없이 같은 액션이면 같은 리소르를 ..

2. 컨트롤러가 리소스를 나눠가짐
이러면 다른 컨트롤러의 스케줄링을 고려할 필요가 없어서 실시간성 이슈가 없어짐

1대의 docker deamon은 10개의 도커 인스턴스만 올릴 수 있다.


#### 문제점

1. 액션간의 간섭

해쉬값을 이용한 라우팅은 핫스팟 현상이 일어난다.

실행 시간이 <=500ms 인 경우 ColdStart 이전 실행을 기다리는 것이 낫다.


시스템의 성능 결정 불가

언제 스케일 아웃?

#### 성능 이슈 극복하기
- 액션별로 별도의 큐를 사용
- 액션의 실행과 컨테이너 생성 분리

#### Pull 기반 스케줄링
컨테이너의 위치를 신경쓰지 않아도됨.

컨테이너의 생성과 액션의 실행을 분리

액션 실행 요청은 실행 요청 큐로, 생성 요청은 생성 요청 큐로 전달된다.

컨테이너의 생성이 기존 실행에 영향을 주지 않게됨.

신규 컴포넌트 도입 ETCD 각 컨트롤러는 자신에게 할당된 리소스를 끼준

ETCD에 주기적으로 상태를 기록 Invoker가?

Kafka를 대체하는 큐를 직접 구현

카프카 토픽은 파티션으로 이뤄짐, Parallelisim의 단위.
특정 파티션을 특정 컨슈머에게 할당하는 과정이 애매해~

컨슈머 리밸런싱. 200개의 파티션을 리밸런싱하는데 50초 이상 소요


#### 결론

액션별 메시지 큐 도입으로 액션간 간섭 문제 해결
Pull 기반 메시지 전송으로 컨테이너 위치를 고려하지 않음
액션의 실행과 ~

네이버에 FaaS는 오픈소스대비 155배 좋아짐.
