3장-함수
===============================
어떤 프로그램이든 기본 단위는 함수이다. 이 장은 함수를 잘 만드는 법을 소개한다.

## 작게 만들어라!
함수를 만드는 첫째 규칙은 '작게!'이다. 함수를 만드는 둘째 규칙은 '더 작게!'다.

최대한 짧게 만드는 것이 좋다. 각 함수가 너무도 명백하게 하나의 이야기만 표현하는 것이 좋다.

## 한 가지만 해라!

**함수는 한 가지를 해야한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**

이 충고에서 문제라면? 그 '한 가지'가 무엇인지 알기가 어렵다는 점이다.

```java
public static string renderPageWithSetupAndTeardowns(PageData pageData, boolean isSuite) {
    if (isTestPage(pageData)) includeSetupTeardownPages(pageData, isSuite);
    return pageData.getHtml();  
}
```

위 함수는 한 가지만 하는가? 세 가지를 한다고 주장할 수 있다.

1. 페이지가 테스트 페이지인지 판단한다.
2. 그렇다면 설정 페이지와 해제 페이지를 넣는다.
3. 페이지를 HTML로 렌더링한다.

함수의 일을 판단할 때는 작업의 갯수가 아니라 추상화 수준을 판단해야한다.

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

함수가 '한 가지'만 하는지 판단하는 방법이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있느 ㄴ이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 내려가기 규칙: 위에서 아래로 코드 읽기
코드는 위에서 아래로 이야기처럼 읽혀야 좋다.

위에서 사용하는 함수는 아래에 정의되는게 좋다.

## 함수 인수
함수에서 이상적인 인수 개수는 0개다. 다음은 1개(단항)이고, 다음은 2개(이항)다. 3개(삼항)는 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다.

인수가 많다면 함수를 이해하기 힘들다. 테스트하기도 힘들다. 최대한 인수를 줄이자.

### 플래그 인수
플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 왜냐고? 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까! 플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까!

### 이항 함수
함수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.

예를 들어 writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 둘다 의미는 명백하지만 전자가 더 쉽게 읽히고 더 빨리 이해된다. 후자는 잠시 주춤하며 첫 인수를 무시해야 한다는 사실을 깨닫는 시간이 필요하다. 그리고 바로 그 사실이 결국은 문제를 일으킨다. 왜냐고? 어떤 코드든 절대로 무시하면 안되니까. 무시한 코드에 오류가 숨어드니까.

위 코드는 outputStream.writeField(name)으로 호출하는 것이 좋다.

### 삼항 함수
인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 그래서 삼항 함수를 만들 때는 신중히 고려하라 권고한다.

### 인수 객체
인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

### 출력 인수
일반적으로 우리는 인수를 함수 입력으로 해석한다.
인수를 출력으로 사용하면 어색하다.

```java
appendFooter(s);
```

이 함수는 무언가에 s를 바닥글로 첨부할텐데,,, 무언가일까?

```java
public void appendFooter(StringBuffer report);
```

인수가 s가 출력으로도 사용한다는 사실은 분명하지만 함수 선언부를 찾아보고 나서야 알 수 있다. 객체 지향 프로그래밍이 나오기 전에는 출력 인수가 불가피한 경우도 있었다.
하지만 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다.

```java
report.appendFooter()
```

## 명령과 조회를 분리하라!
함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면안된다.


## 오류 코드보다 예외를 사용하라!

```java
if (deletePage(page) == E_OK) {
  if(registry.deleteReference(page.name) == E_OK) {
    if(configKeys.deleteKey(page.name.makeKey() == E_OK)) {
      logger.log("page deleted");
    } else {
      logger.log("configKey not deleted");
    }
  } else {
    logger.log("deleteReference from registry failed");
  }
} else {
  logger.log("delete failed");
  return E_ERROR;
}
```

위 오류 코드 대신 예외를 사용하면 아래처럼 코드에서 오류 처리가 분리되므로 코드가 깔끔해진다.

```java
try {
  deletePage(page);
  registry.deleteReference(page.name);
  configKeys.deleteKey(page.name.makeKey());
} catch (Exception e) {
  logger.log(e.getMessage());
}
```

### 오류 처리도 한 가지 작업이다.
함수는 '한 가지' 작업만 해야한다. 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.


## 함수를 어떻게 짜죠?
 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 초안은 대게 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다. 내가 함수를 짤 때도 마찬가지다. 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드는 중복된다. 하지만 나는 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다. 그런 다음 나는 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다.
 
