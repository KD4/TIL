# Vuex
Vue로 만든 어플리케이션의 상태관리패턴 & 라이브러리

- [store](./vuex-state.md)

## 상태관리패턴은 왜 필요할까 ?
하나의 뷰 인스턴스는 다음과 같이 상태, 뷰, 액션 구조를 가집니다.
```javascript
new Vue({
  // 상태
  data () {
    return {
      count: 0
    }
  },
  // 뷰
  template: `
    <div>{{ count }}</div>
  `,
  // 액션
  methods: {
    increment () {
      this.count++
    }
  }
})
```

- 상태 : 앱을 작동하기 위한 메타(기본)데이터
- 뷰 : 상태에 대한 매핑으로 상태 값에 따라 변함
- 액션 : 뷰에서 발생하는 행위, 상태를 바꿀 수 있음.

위 설명에서 알 수 있듯이 데이터는 단방향으로 흐릅니다. (..상태->뷰->액션->상태..)

그러나 공통의 상태를 공유하는 여러 컴포넌트 가 있는 경우 단순함이 빠르게 저하됩니다.

여러 뷰는 같은 상태에 의존합니다.

서로 다른 뷰의 작업은 동일한 상태를 반영해야 할 수 있습니다.

첫번째 문제의 경우, 지나치게 중첩된 컴포넌트는 통과하는 prop는 장황할 수 있으며 형제 컴포넌트에서는 작동하지 않습니다. 두번째 문제의 경우 직접 부모/자식 인스턴스를 참조하거나 이벤트를 통해 상태의 여러 복사본을 변경 및 동기화 하려는 등의 해결 방법을 사용해야 합니다. 이러한 패턴은 모두 부서지기 쉽고 유지보수가 불가능한 코드로 빠르게 변경됩니다.

그렇다면 컴포넌트에서 공유된 상태를 추출하고 이를 전역 싱글톤으로 관리해야 합니다. 이를 통해 우리의 컴포넌트 트리는 커다란 "뷰"가 되며 모든 컴포넌트는 트리에 상관없이 상태에 액세스하거나 동작을 트리거 할 수 있습니다!

또한 상태 관리 및 특정 규칙 적용과 관련된 개념을 정의하고 분리함으로써 코드의 구조와 유지 관리 기능을 향상시킵니다.

이는 Flux, Redux, The Elm Architecture에서 영감을 받은 Vuex의 기본 아이디어 입니다. 다른 패턴과 달리 Vuex는 Vue.js가 효율적인 업데이트를 위해 세분화된 반응 시스템을 활용하도록 특별히 고안된 라이브러리입니다.
